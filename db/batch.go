// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: batch.go

package db

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v4"
)

const createDependency = `-- name: CreateDependency :batchmany
WITH ins AS (
    INSERT INTO dependency (
        id, name, version, type, is_local
    ) SELECT
        COALESCE(MAX(id), 0) + 1,
        $1, $2, $3, $4
    FROM dependency
    WHERE NOT EXISTS (
        SELECT 1 FROM dependency WHERE name = $1 AND version = $2 AND type = $3
    )
    ON CONFLICT DO NOTHING
    RETURNING id, name, version, type, is_local
)
SELECT id, name, version, type, is_local FROM dependency d
WHERE d.name = $1
    AND d.version = $2
    AND d.type = $3
UNION ALL
SELECT id, name, version, type, is_local FROM ins
`

type CreateDependencyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateDependencyParams struct {
	Name    string
	Version string
	Type    PackageType
	IsLocal bool
}

func (q *Queries) CreateDependency(ctx context.Context, arg []CreateDependencyParams) *CreateDependencyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Name,
			a.Version,
			a.Type,
			a.IsLocal,
		}
		batch.Queue(createDependency, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateDependencyBatchResults{br, len(arg), false}
}

func (b *CreateDependencyBatchResults) Query(f func(int, []Dependency, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []Dependency
		if b.closed {
			if f != nil {
				f(t, items, errors.New("batch already closed"))
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			defer rows.Close()
			if err != nil {
				return err
			}
			for rows.Next() {
				var i Dependency
				if err := rows.Scan(
					&i.ID,
					&i.Name,
					&i.Version,
					&i.Type,
					&i.IsLocal,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *CreateDependencyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertDepDependency = `-- name: InsertDepDependency :batchexec
INSERT INTO dep_dependency (
    parent_id, dependency_id
) VALUES (
    $1, $2
)
ON CONFLICT DO NOTHING
`

type InsertDepDependencyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertDepDependencyParams struct {
	ParentID     int64
	DependencyID int64
}

func (q *Queries) InsertDepDependency(ctx context.Context, arg []InsertDepDependencyParams) *InsertDepDependencyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ParentID,
			a.DependencyID,
		}
		batch.Queue(insertDepDependency, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertDepDependencyBatchResults{br, len(arg), false}
}

func (b *InsertDepDependencyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, errors.New("batch already closed"))
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertDepDependencyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertDeployment = `-- name: InsertDeployment :batchexec
INSERT INTO deployment (
    commit_sha, application, environment, version, run_type
) VALUES (
    $1, $2, $3, $4, $5
)
`

type InsertDeploymentBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertDeploymentParams struct {
	CommitSha   string
	Application string
	Environment string
	Version     string
	RunType     string
}

func (q *Queries) InsertDeployment(ctx context.Context, arg []InsertDeploymentParams) *InsertDeploymentBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.CommitSha,
			a.Application,
			a.Environment,
			a.Version,
			a.RunType,
		}
		batch.Queue(insertDeployment, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertDeploymentBatchResults{br, len(arg), false}
}

func (b *InsertDeploymentBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, errors.New("batch already closed"))
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertDeploymentBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertPackageFileDependency = `-- name: InsertPackageFileDependency :batchexec
INSERT INTO package_file_dependency (
    package_file_id, dependency_id
) VALUES (
    $1, $2
)
ON CONFLICT DO NOTHING
`

type InsertPackageFileDependencyBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertPackageFileDependencyParams struct {
	PackageFileID int64
	DependencyID  int64
}

func (q *Queries) InsertPackageFileDependency(ctx context.Context, arg []InsertPackageFileDependencyParams) *InsertPackageFileDependencyBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.PackageFileID,
			a.DependencyID,
		}
		batch.Queue(insertPackageFileDependency, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertPackageFileDependencyBatchResults{br, len(arg), false}
}

func (b *InsertPackageFileDependencyBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, errors.New("batch already closed"))
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertPackageFileDependencyBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
